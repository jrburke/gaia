/*jshint browser: true */
/*global define, console */
define(function(require) {
  'use strict';

  var co = require('co'),
      appSelf = require('app_self'),
      evt = require('evt'),
      mozL10n = require('l10n!'),
      notificationHelper = require('shared/js/notification_helper');

  // Version marker for the notification data format. It is a string because
  // query_string only deals in strings. If the format of the notification data
  // changes, then this version needs to be changed.
  var notificationDataVersion = '1';

  // The expectation is that this module is called as part of model's
  // init process that calls the "model_init" module to finish its construction.
  return function syncInit(model, api) {
    var hasBeenVisible = !document.hidden;

    // Let the back end know the app is interactive, not just
    // a quick sync and shutdown case, so that it knows it can
    // do extra work.
    if (hasBeenVisible) {
      api.setInteractive();
    }

    // If the page is ever not hidden, then do not close it later.
    document.addEventListener('visibilitychange',
      function onVisibilityChange() {
        if (!document.hidden) {
          hasBeenVisible = true;
          api.setInteractive();
        }
    }, false);

    var doNotCloseYetPromise = null;

    var sendNotification;
    if (typeof Notification !== 'function') {
      console.log('email: notifications not available');
      sendNotification = function() {};
    } else {
      sendNotification = function(notificationId, titleL10n, bodyL10n,
                                  iconUrl, data, behavior) {
        console.log('Notification sent for ' + notificationId);

        if (Notification.permission !== 'granted') {
          console.log('email: notification skipped, permission: ' +
                      Notification.permission);
          return;
        }

        data = data || {};

        // TODO: consider setting dir and lang?
        //https://developer.mozilla.org/en-US/docs/Web/API/notification
        var notificationOptions = {
          bodyL10n: bodyL10n,
          icon: iconUrl,
          tag: notificationId,
          data: data,
          mozbehavior: {
            noscreen: true
          },
          closeOnClick: false
        };

        if (behavior) {
          Object.keys(behavior).forEach(function(key) {
            notificationOptions.mozbehavior[key] = behavior[key];
          });
        }

        notificationHelper.send(titleL10n, notificationOptions)
          .then(function(notification){
            // If the app is open, but in the background, when the notification
            // comes in, then we do not get notifived via our
            // mozSetMessageHandler that is set elsewhere. Instead need to
            // listen to click event and synthesize an "event" ourselves.
            notification.onclick = function() {
              evt.emit('notification', {
                clicked: true,
                imageURL: iconUrl,
                tag: notificationId,
                data: data
              });
            };
          });
      };
    }

    /**
     * Fetches notification data for the notification type, ntype. This method
     * assumes there is only one ntype of notification per account.
     * @param  {String} ntype The notification type, like 'sync'.
     * @return {Promise}      Promise that resolves to a an object whose keys
     * are account IDs and values are notification data.
     */
    function fetchNotificationsData(ntype) {
      if (typeof Notification !== 'function' || !Notification.get) {
        return Promise.resolve({});
      }

      return Notification.get().then(function(notifications) {
        var result = {};
        notifications.forEach(function(notification) {
          var data = notification.data;

          // Want to avoid unexpected data formats. So if not a version match
          // then just close it since it cannot be processed as expected. This
          // means that notifications not generated by this module may be
          // closed. However, ideally only this module generates notifications,
          // for localization of concerns.
          if (!data.v || data.v !== notificationDataVersion) {
            notification.close();
          } else if (data.ntype === ntype) {
            data.notification = notification;
            result[data.accountId] = data;
          }
        });
        return result;
      }, function(err) {
        // Do not care about errors, just log and keep going.
        console.error('email notification.get call failed: ' + err);
        return {};
      });
    }

    /**
     * Helper to just get some environment data for dealing with sync-based
     * notfication data. Exists to reduce the curly brace pyramid of doom and
     * to normalize existing sync notification info.
     * @param {Function} fn function to call once env info is fetched.
     */
    function getSyncEnv() {
      return new Promise((resolve) => {
        appSelf.latest('self', function(app) {
          // todo: a comment is needed here to explain the guarantee that model
          // will select an account and folder as part of its startup process.
          // The semantic of `latest` mean that these could otherwise be
          // footguns that hang the notification-generation process.
          model.latestOnce('account', function(currentAccount) {
            model.latestOnce('folder', function(currentFolder) {
              fetchNotificationsData('sync').then(
                function(existingNotificationsData) {
                  mozL10n.formatValue('senders-separation-sign')
                  .then(function(separator) {
                    var localized = {
                      separator
                    };
                    mozL10n.formatValue('notification-no-subject')
                    .then(function(noSubject) {
                      localized.noSubject = noSubject;
                      resolve({
                        app,
                        currentAccount,
                        currentFolder,
                        existingNotificationsData,
                        localized
                      });
                    });
                });
              });
            });
          });
        });
      });
    }

    /**
     * This event is sent with the current set of new (inbox) messages changes.
     * This goes for both new "new" messages as well as a reduction in the set
     * because some other client read/deleted the messages.  In particular, the
     * update will be sent when:
     *
     * - A cronsync batch completes.  Changes will be accumulated during the
     *   cronsync process and the update only generated when the batch has
     *   completed.
     *
     * - A normal sync completes that covers the inbox folder.  This could be
     *   because user action explicitly caused a sync of the folder, or because
     *   the account is something like gmail where any refresh sync of any
     *   folder will also result in the sync being updated.
     */
    api.on('newMessagesUpdate', (newAggr) => {
      doNotCloseYetPromise = processNewMessagesUpdate(newAggr);
      doNotCloseYetPromise.then(() => {
        doNotCloseYetPromise = null;
      });
    });

    var processNewMessagesUpdate = co.wrap(function*(newAggr) {
      // There are sync updates, get environment and figure out how to notify
      // the user of the updates.
      let { app, currentAccount, currentFolder, existingNotificationsData,
            localized } =
        yield getSyncEnv();

      let iconUrl = notificationHelper.getIconURI(app);

      for (let [accountId, perAccountData] of newAggr) {
        let existingData = existingNotificationsData[accountId];

        if (perAccountData === null) {
          // -- No new messages for this account!
          // Revoke any outstanding notification if there is one.
          if (existingData) {
            try {
              existingData.notification.close();
            } catch(ex) {
              console.warn('problem closing notification:', ex);
            }
          }
          // All done for this account.
          continue;
        }

        if (hasBeenVisible &&
            currentAccount && currentAccount.id === accountId &&
            currentFolder && currentFolder.type === 'inbox') {
          // -- Displaying this account's inbox right now as-is.
          // Is the user currently looking at this account's inbox?  Then we
          // don't need to generate a notification because the 'syncComplete'
          // mechanism that message_list uses to do its blue new bar will handle
          // things for us.  (Including waiting for the user to return to the
          // message list from the reader, etc.)
          //
          // (The hasBeenVisible check is to ensure that we don't get faked out
          // by the model auto-selecting an account and folder even when we're
          // pure background.)

          // However, we do want to immediately clear the new tracking.  And
          // there's no need to flush this change back down to us.
          currentAccount.clearNewTracking({ silent: true });
          continue;
        }

        // If we're at this point, then we know that we definitely want to
        // generate/update the notification.  (Note that we checked the
        // notifyOnNew pref in our app_logic/new_batch_churn.js implementation.)

        let dataObject, subjectL10n, bodyL10n, behavior;
        let { newMessageCount } = perAccountData;

        // Branch for localization customization reasons on the number of
        // new messages.  Note that our app_logic pre-chewed everything but
        // the 'layout' of our notification and choice of l10n id's.
        if (newMessageCount > 1) {
          // -- Multiple messages!
          let { topFromAddresses: fromNames } = perAccountData;

          dataObject = {
            v: notificationDataVersion,
            ntype: 'sync',
            type: 'message_list',
            accountId,
            count: newMessageCount
          };

          // If already have a notification, then do not bother with sound or
          // vibration for this update. Longer term, the notification standard
          // will have a "silent" option, but using a non-existent URL as
          // suggested in bug 1042361 in the meantime.
          if (existingData && existingData.count) {
            behavior = {
              soundFile: 'does-not-exist-to-simulate-silent',
              // Cannot use 0 since system/js/notifications.js explicitly
              // ignores [0] values. [1] is good enough for this purpose.
              vibrationPattern: [1]
            };
          }

          // We only get told the accountName if there are multiple accounts.
          let { accountName } = perAccountData;
          if (accountName) {
            subjectL10n = {
              id: 'new-emails-notify-multiple-accounts',
              args: {
                n: newMessageCount,
                accountName
              }
            };
          } else {
            subjectL10n = {
              id: 'new-emails-notify-one-account',
              args: { n: newMessageCount }
            };
          }

          bodyL10n = { raw: fromNames.join(localized.separator) };
        } else {
          // Only one message to notify about.
          dataObject = {
            v: notificationDataVersion,
            ntype: 'sync',
            type: 'message_reader',
            accountId,
            messageSuid: perAccountData.messageId,
            count: 1
          };

          let rawSubject = perAccountData.subject || localized.noSubject;

          // We only get told the accountName if there are multiple accounts.
          let { accountName } = perAccountData;
          if (accountName) {
            subjectL10n = {
              id: 'new-emails-notify-multiple-accounts',
              args: {
                n: newMessageCount,
                accountName
              }
            };
            bodyL10n = {
              id: 'new-emails-notify-multiple-accounts-body',
              args: {
                from: perAccountData.fromAddress,
                subject: rawSubject
              }
            };
          } else  {
            subjectL10n = { raw: rawSubject };
            bodyL10n = { raw: perAccountData.fromAddress };
          }
        }

        sendNotification(
          accountId,
          subjectL10n,
          bodyL10n,
          iconUrl,
          dataObject,
          behavior
        );
      }
    });

    /**
     * This event is sent when the cronsync batch has completed without any
     * fatal breakage occurring.  (It's still possible we failed to actually
     * sync anything!)  It will be generated after any 'newMessagesUpdate', if
     * any.  *However*, the back-end has no idea if newMessagesUpdate is doing
     * something synchronous, which is why we do our little dance with
     * doNotCloseYetPromise.
     *
     * This is the time to close the app if appropriate.
     */
    api.on('cronSyncComplete', () => {
      if (!hasBeenVisible) {
        console.log('sync complete, going to close mail app');
        if (doNotCloseYetPromise) {
          doNotCloseYetPromise.then(() => {
            console.log('actually closing mail app now that promise resolved.');
            window.close();
          });
        } else {
          console.log('closing immediately');
          window.close();
        }
      }
    });

    /**
     * This event is sent when the cronsync process broke and it's likely the
     * email app is now broken.  We will accordingly close the app.
     */
    api.on('cronSyncEpicFail', () => {
      console.error('CronSync says it broke, closing app.');
      if (hasBeenVisible) {
        console.error('Yes, despite the fact we were previously visible.');
      }
      window.close();
    });

    // Background Send Notifications

    var BACKGROUND_SEND_NOTIFICATION_ID = 'backgroundSendFailed';
    var sentAudio = null; // Lazy-loaded when first needed

    /**
     * The API passes through background send notifications with the
     * following data (see the "sendOutboxMessages" job and/or
     * `GELAM/js/jobs/outbox.js`):
     *
     * @param {int} accountId
     * @param {string} suid
     *   SUID of the message
     * @param {string} state
     *   'pending', 'syncing', 'success', or 'error'
     * @param {string} err
     *   (if applicable, otherwise null)
     * @param {array} badAddresses
     *   (if applicable)
     * @param {int} sendFailures
     *   Count of the number of times the message failed to send.
     * @param {Boolean} emitNotifications
     *   True if this message is being sent as a direct result of
     *   the user sending a message from the compose window. False
     *   otherwise, as in when the user "refreshes" the outbox.
     * @param {Boolean} willSendMore
     *   True if we will send a subsequent message from the outbox
     *   immediately after sending this message.
     *
     * Additionally, this function appends the following to that
     * structured data:
     *
     * @param {string} localizedDescription Notification text.
     *
     * If the application is in the foreground, we notify the user on
     * both success and failure. If the application is in the
     * background, we only post a system notifiaction on failure.
     *
     * TODO: hook this all back up again.  see
     * https://bugzilla.mozilla.org/show_bug.cgi?id=1241348
     */
    api.onbackgroundsendstatus = function(data) {
      console.log('outbox: Message', data.suid, 'status =', JSON.stringify({
        state: data.state,
        err: data.err,
        sendFailures: data.sendFailures,
        emitNotifications: data.emitNotifications
      }));

      // Grab an appropriate localized string here. This description
      // may be displayed in a number of different places, so it's
      // cleaner to do the localization here.

      var descId;
      switch (data.state) {
      case 'pending': descId = 'background-send-pending'; break;
      case 'sending': descId = 'background-send-sending'; break;
      case 'success': descId = 'background-send-success'; break;
      case 'error':
        if ((data.badAddresses && data.badAddresses.length) ||
            data.err === 'bad-recipient') {
          descId = 'background-send-error-recipients';
        } else {
          descId = 'background-send-error';
        }
        break;
      case 'syncDone':
        // We will not display any notification for a 'syncDone'
        // message, except to stop refresh icons from spinning. No
        // need to attempt to populate a description.
        break;
      default:
        console.error('No state description for background send state "' +
                      data.state + '"');
        return;
      }

      // If the message sent successfuly, and we're sending this as a
      // side-effect of the user hitting "send" on the compose screen,
      // (i.e. emitNotifications is true), we may need to play a sound.
      if (data.state === 'success') {
        // Grab an up-to-date reading of the "play sound on send"
        // preference to decide if we're going to play a sound or not.
        model.latestOnce('accounts', () => {
          var account = model.getAccount(data.accountId);
          if (!account) {
            console.error('Invalid account ID', data.accountId,
                          'for a background send notification.');
            return;
          }

          // If email is in the background, we should still be able to
          // play audio due to having the 'audio-channel-notification'
          // permission (unless higher priority audio is playing).

          // TODO: As of June 2014, this behavior is still in limbo;
          // see the following links for relevant discussion. We may
          // need to follow up to ensure we get the behavior we want
          // (which is to play a sound when possible, even if we're in
          // the background).
          //   Thread on dev-gaia: http://goo.gl/l6REZy
          //   AUDIO_COMPETING bugs: https://bugzil.la/911238
          if (account.playSoundOnSend) {
            if (!sentAudio) {
              sentAudio = new Audio('/sounds/firefox_sent.opus');
              sentAudio.mozAudioChannelType = 'notification';
            }
            sentAudio.play();
          }
        });
      }

      // If we are in the foreground, notify through the model, which
      // will display an in-app toast notification when appropriate.
      if (!document.hidden) {
        mozL10n.formatValue(descId).then(function(localizedDescription) {
          data.localizedDescription = localizedDescription;
          model.notifyBackgroundSendStatus(data);
        });
      }
      // Otherwise, notify with a system notification in the case of
      // an error. By design, we don't use system-level notifications
      // to notify the user on success, lest they get inundated with
      // notifications.
      else if (data.state === 'error' && data.emitNotifications) {
        appSelf.latest('self', function(app) {
          var iconUrl = notificationHelper.getIconURI(app);
          var dataObject = {
            v: notificationDataVersion,
            ntype: 'outbox',
            type: 'message_reader',
            folderType: 'outbox',
            accountId: data.accountId,
            messageSuid: data.suid
          };

          sendNotification(
            BACKGROUND_SEND_NOTIFICATION_ID,
            'background-send-error-title',
            descId,
            iconUrl,
            dataObject
          );
        });
      }
    };

    // When inbox is viewed, be sure to clear out any possible notification
    // for that account.
    evt.on('inboxShown', function(accountId) {
      api.clearNewTrackingForAccount({
        accountId,
        // don't be silent, we do want a newMessagesUpdate event to fire and
        // remove the notification.
        silent: false
      });
    });
  };
});
